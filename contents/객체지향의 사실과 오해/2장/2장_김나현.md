# 02. 이상한 나라의 객체

> 객체지향 패러다임은 지식을 추상화하고 추상화한 지식을 객체 안에 캡슐화함으로써 실세계 문제에 내재된 복잡성을 관리하려고 한다. 객체를 발견하고 창조하는 것은 지식과 행동을 구조화하는 문제다.
<br> - 레베카 워프스브록

## 객체지향과 인지능력

객체란 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것이다.

객체지향 패러다임은 
인간이 인지할 수 있는 다양한 객체들이 모여 현실 세계를 이루는 것처럼, <br>
소프트웨어의 세계 역시 인간이 인지할 수 있는 다양한 소프트웨어 객체들이 모여 이뤄져 있다는 믿음에서 출발한다.

하지만 `객체지향 패러다임의 목적`은 현실 세계를 모방하는 것이 아닌 더 나아가 현실세계를 기반으로 **새로운 세계를 창조하는 것** 이다. 

> 소프트웨어 세계에서의 객체 != 현실세계에 존재하는 객체의 모습

실행중인 객체지향 애플리케이션 내부는 우리의 실세계와 유사해보이지만 본질적으로는 매우 이질적인 모습을 가지고 있다. 
그 세계를 책 [이상한 나라의 앨리스] 속 이상한 나라에 빗대어 본다.

---

## 객체 그리고 이상한 나라

### 이상한 나라의 앨리스

- 앨리스 객체

앨리스는 정원으로 가는 길을 가로막고 있는 작은 문을 통과하기 위해 자신의 키를 줄이거나 늘렸다. 정원으로 통하는 문을 통과하기 위해 자신의 키를 계속 변화시킨 것이다.

문을 통과하기에 `적당한 상태`란 문을 통과하기에 `적절한 키`를 의미한다. 

**특정 시점의 앨리스의 상태 = 특정 시점의 앨리스의 키**

앨리스의 키는 '음료를 마시는 행위 혹은 부채질, 버섯이나 케이크 섭취'와 같은 행동을 통해 변화할 수 있다. <br>
앨리스의 키를 변화시키는 것은 앨리스의 행동이다.

**앨리스의 행동에 따라 앨리스의 상태가 변한다.**

> `앨리스의 상태를 결정하는 것은 행동이지만, 행동의 결과를 결정하는 것은 상태` <br>
> 따라서 앨리스가 한 행동의 결과는 앨리스의 상태에 의존적이다.

행동의 결과 = 문을 통과한다. / 
앨리스의 상태 = 문을 통과할 수 있는 키

> 행동 간의 `순서` 도 중요하다. 문을 통과하는 행동을 성공하려면 음료나 케이크를 먹는 행동이 선행 되어야 한다. <br>
> 상태 변경과 무관하게 앨리스는 유일한 존재로 식별 가능하다.

앨리스의 특징을 정리해보자면,
- 앨리스는 상태를 가지며 상태는 변경 가능하다.
- 앨리스의 상태를 변경시키는 것은 앨리스의 행동이다. (행동의 순서가 결과에 영향을 미치며, 행동의 결과는 상태에 의존적이다.)
- 앨리스가 어떤 상태에 있더라도 유일하게 식별 가능하다.

### 객체, 그리고 소프트웨어 나라

객체란,
- 식별 가능한 개체 또는 사물
- 구체적인 사물(자동차), 추상적인 개념(시간) 모두 가능하다
- 구별 가능한 **식별자(identity)**, 특징적인 **행동**, 변경 가능한 **상태** 를 가진다

> 상태

어떤 행동의 결과는 과거에 어떤 행동들이 일어났었느냐에 의존한다는 것. <br>
-> eg. 텔레비전 전원을 켜지 않는 한 채널을 변경할 수 없다.

상태를 이용함으로써 과거의 모든 행동 이력을 설명하지 않고도, 행동의 결과를 쉽게 예측할 수 있다. <br>
상태는 근본적으로 세상의 복잡성을 완화하고 인지 과부하를 줄일 수 있는 중요한 개념이다.

즉, `앨리스의 키`와 `문의 높이` 두 가지 상태 -> 행동의 결과를 예측 가능!

> 상태와 프로퍼티

숫자, 문자열, 양, 속도, 시간, 참/거짓과 같은 단순한 값들은 객체가 아니다. 
단순한 값들은 그 자체로 독립적인 의미를 가지기보다는 다른 객체의 상태를 표현하기 위해 사용된다.

- 앨리스의 위치 -> 문자열
- 음료와 케이크의 양 -> 숫자
- 문이 열려있는지 여부 -> 참/거짓

=> `단순한 값`은 객체는 ❌ / **객체의 상태** 를 표현하는 중요한 수단

> 앨리스(키: 130cm, 위치: "통로") --------------- 음료(양: 0.5l)

- 프로퍼티(property): 객체의 상태를 구성하는 모든 특징 (**정적**)
    - eg. 앨리스의 프로퍼티 : 앨리스의 키, 위치, 음료
- 프로퍼티 값(property value) : 시간이 흐름에 따라 변경된다 (**동적**)
    - eg. 앨리스의 키는 음료를 마시면 작아질 것, 위치는 문을 통과하면 정원으로 바뀔 것, 음료를 다 마시면 버릴 것.

> 앨리스(키: 40cm, 위치: "정원")         음료(양: 0.5l)

다른 시점에 바뀐 앨리스의 상태를 표현한 것으로, 음료를 다 마시고 버림으로써 선이 사라졌다.
이 시점에는 음료에 관해 알지 못하는 상태로 변경됐음을 의미한다.

- `링크(link)` : 객체와 객체 사이의 의미 있는 연결 <br>
객체의 링크가 존재해야지만 메세지를 주고받을 수 있으며, 객체가 다른 객체를 참조할 수 있다는 것을 의미한다. <br>
  -> `한 객체가 다른 객체의 식별자를 알고 있는 것으로 표현`
  
- `속성(attribute)` : 객체를 구성하는 단순한 값 <br>
    - eg. 앨리스의 키와 위치
  
- `프로퍼티(property)` : 속성과 링크의 조합
  
### 객체의 상태
- 상태: 특정 시점에 객체가 가지고 있는 정보의 집합
- 정적인 프로퍼티, 동적인 프로퍼티로 구성
- 객체의 프로퍼티는 단순한 값(속성)과 다른 객체를 참조하는 링크로 구분

객체는 자율적인 존재로 외부의 객체가 직접적으로 다른 객체의 상태를 주무를 수 없다.
간접적으로 객체의 상태를 변경하거나 조회해야하는데 `행동`을 통해 간접적으로 할 수 있다.

> 행동 

- 객체가 취하는 행동은 객체 자신의 상태를 변경시킨다.(부수효과(side effect)를 초래한다) <br>
    ->  eg. 앨리스가 문을 통과하는 행동 -> 앨리스의 위치를 변화시킨다(부수효과)
- 객체의 행동은 객체의 상태를 변경시키지만, 행동의 결과는 객체의 상태에 의존한다. <br>
    -> eg. 앨리스의 키가 40cm 이하라면 문을 열 수 있다. <br>
    -> eg. 문을 통과한 후에 앨리스의 위치는 정원으로 바뀌어야 한다.
  
> 협력과 행동 

`협력하는 객체들의 공동체`를 만들기 위해 객체들은 노력한다.  객체는 다른 객체와 `메시지`를 통해서만 의사소통할 수 있다.

객체가 어떤 행동을 하도록 만드는 것은 객체가 외부로부터 수신한 메시지이다.
수신된 메시지에 따라 적절히 행동하면서 협력에 참여하고 그 결과로 자신의 상태를 변경한다.

협력하는 과정에서 자신의 상태변화 뿐만 아니라 다른 객체의 상태변화 또한 유발할 수 있다.
eg. 앨리스의 음료를 마시는 행동은 자기 자신 뿐 아니라 음료 객체의 상태 변경도 유발한다.

- `객체의 행동으로 인해 발생하는 결과`
    - 객체 자신의 상태 변경
    - 행동 내에서 협력하는 다른 객체에 대한 메시지 전송
    

### 상태 캡슐화

- 현실세계에서는 음료 객체는 수동적인 존재이다. <br>
그러나 객체지향 세계에서 음료 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다.<br>
고로 음료 객체의 양을 줄이는 것도 음료 자기자신이어야 한다.
<br>
- 음료의 양을 줄어들 것인지는 메시지를 수신한 음료가 결정할 사항이며, 앨리스와는 무관하다.
단지 앨리스는 음료의 양이 줄어들 것이라고 믿고 요청을 전달할 뿐이다.(메시지 전송)
  <br>
- 메시지 송신자는 메시지 수신자의 상태 변경에 대해서는 전혀 알지 못한다. (캡슐화)
  <br>
- 캡슐화
    - 객체의 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. (외부에 노출할 수 있는 방법, 접근할 수 있는 방법은 오로지 행동 뿐!)
  <br>
- 캡슐화 -> 객체의 자율성을 높인다. 
  - 객체의 자율성이 높아질수록 객체의 지능도 높아진다. (-> 협력이 유연해지고 간결해짐)

> **[캡슐화 하는 이유]** 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.

### 식별자

- **객체가 식별가능하다?**
    - 객체를 서로 구별할 수 있는 특별한 프로퍼티가 객체 안에 존재한다는 것
<br><br>
      
- **값(value)** (동등성)
    - 흔히 값의 상태는 변하지 않는 `불변 상태(immutable state)`
    - 인스턴스 값이 동일하면 같다고 본다.
- 동등성(equality)
    - 상태를 이용해 두 값이 같은지 판단할 수 있는 성질 (값의 상태가 같으면 두 인스턴스는 동일한 것으로 판단)
    - 값의 상태가 변하지 않기 때문에 판단 가능
  <br><br>

- 객체 (동일성)
    - 시간에 따라 변경되는 상태를 포함하며, 행동을 통해 상태를 변경한다.
    - `가변 상태(mutable state)`
    - 상태가 동일하더라도 별개의 인격체
- 동일성(identical)
    - 식별자를 기반으로 객체가 같은지 판단할 수 있는 성질
    - 시간의 흐름에 따라 객체의 상태가 변하기 때문
    
    
cf. 
- `식별자를 지닌 객체` : 참조 객체(reference object) 또는 엔티티(entity)
- `값 객체(value object)` : 식별자를 가지지 않는 값
<br><br>
- 객체는 식별자를 가진 구분할 수 있는 존재이다.

### 기계로서의 객체

객체지향의 세계를 창조하는 개발자들의 주된 업무는
`객체의 상태를 조회`하고, `객체의 상태를 변경`하는 것

- 쿼리(query): 객체의 상태를 조회하는 작업
- 명령(command): 객체의 상태를 변경하는 작업
<br><br>

- 객체에 접근할 수 있는 유일한 방법: 객체의 행동
- 객체가 외부에 제공하는 행동: 명령, 쿼리

객체지향 패러다임 관점에서, 앨리스가 음료를 마시는 행위는 <br>
'음료를 마시다' 메시지를 수신한 앨리스 객체가 '마셔지다'라는 메시지를 음료 객체에게 전송한 것과 동일하다.

-> `링크`를 통해 연결된 두 객체가 `메시지 전송`을 통해 `협력` 하고 있다.

### 행동이 상태를 결정한다

상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 미친다.

1. 상태를 먼저 결정할 경우 캡슐화가 저해된다. 
2. 객체를 협력자가 아닌 고립된 섬으로 만든다. <br>
    객체가 필요한 이유는 다른 객체와 협력하기 위함이다.
3. 객체의 재사용성이 저하된다.<br>
   상태에 초점을 맞추면 다양한 협력에 참여하기 어려우므로 재사용성이 저하된다.
   
> 협력에 참여하는 좋은 객체를 만들기 위해서는 상태가 아닌 **행동** 에 초점을 맞추자


객체의 행동은 결국 객체가 협력하면서 완수해야할 **책임** 을 의미한다.
`따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도한다.`

### ✅ 행동이 상태를 결정한다.

### 은유와 객체

- 추상화(abstraction)
    - 실제 사물에서 자신이 원하는 특성만 취하고
    - 필요 없는 부분을 추려 핵심만 표현하는 행위

그러나 객체지향 세계는 현실 세계의 단순한 모방이 아닌, 실제 세계와는 전혀 다른 양상을 띤다. (새로운 세계 재창조)

### 현실 속의 객체 vs 소프트웨어 객체 사이의 차이점?
- 현실에서의 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다는 것!
(-> 객체의 의인화(anthropomorphism)
<br><br>
- 의인화 관점에서 소프트웨어를 생물로 생각하자. 모든 생물처럼 소프트웨어는 태어나고, 삶을 영위하고, 그리고 죽는다.


그렇다고 객체지향의 세계와 현실 세계는 전혀 상관이 없진 않다.
둘 세계 사이의 관계를 **은유(metaphor)** 라고 볼 수 있다.

현실 속의 객체를 바탕으로 은유를 통해 객체를 묘사하는 것.
객체지향 설계자로서 우리의 목적은 현실을 모방하는 것이 아닌, 이상한 나라를 창조하기만 하면 된다.

현실 세계를 닮아야 한다는 어떤 제약이나 구속도 없이, 창조한 객체의 특성을 상기시킬 수 있다면.
현실 속의 객체의 이름을 이용해 객체를 묘사함으로써. 

깔끔하게 현실을 무시하고 자유롭게 새로운 세계를 재창조하자!

---

### 🧐 의문점

객체들은 자율적인 존재로써 캡슐화되어 자신의 상태를 관리하고 행동을 통해 다른 객체에게 메시지를 전송함으로써 간접적으로 영향을 줄 수 있다는 것을 알게되었다.
객체의 자율성이 높아질수록 협력에 유연한 설계를 할 수 있기에 객체의 지능이 높아질 수 있다고 했다. 코드릁 통한 좀 더 구체적인 예시가 궁금하다.

좋은 객체지향을 설계하기 위해선 상태가 아닌 행동에 초점을 맞추고 설계해야한다고 했는데 어떤 방식으로 설계하는지 궁금하다.



