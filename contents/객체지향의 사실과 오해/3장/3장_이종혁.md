# 추상화

### 추상화의 대표적인 예시 **`지하철 노선도`**
> 대부분의 사람들은 우리나라 수도권의 어디를 가던 큰 걱정을 하지 않는다.   
> 그 이유는 지하철 노선도가 잘 구축되어 있기 때문인데
> 예를 들어, 임학역에서 신논현역으로 가보자.   
> 별도의 길 찾기 시스템이 없더라도 우리는 노선도를 따라서 각자의 경로를 머릿속에 그릴 것이다.   
> 가장 효율적인 경로는 임학->계양->김포공항->신논현 일 것이다.    
> 다른 경로로는 임학->부평구청->고속 터미널->신논현이 있다.   


### 이렇듯 지하철 노선도에서 출발지, 도착지만 알아도 어떻게 갈지, 어디서 환승할지 직관적으로 알 수 있다



> 과연 처음부터 지하철 노선도가 직관적이었을까?    결론부터 말하자면 아니다.
> 1927년 스팅모어가 디자인한 초기의 런던 지하철 노선도는 실제와 유사한 물리적인 지형 위에 구불구불한
> 운행 노선과 불규칙적인 역 간의 거리를 사실적으로 묘사하여 직관성이 떨어졌다


<img src="..\images\trainmap_old.jpg" width="500"/>   


### 불필요한 사실적인 정보를 제외하고 "목적"에 집중해보자
> 해리 벡은 1933년에 사실직인 지형과 축적, 역 간의 거리, 지하철의 이동 경로를 모두 제외하고 역의 순서와 갈아타는 역의 표시에만 집중했다.

<img src="..\images\trainmap_new.jpg" width="500"/>   

### '정확성'을 버리고 '목적'에 집중해 추상화를 한 결과 매우 직관적인 지하철 노선도가 만들어졌다.


## 추상화란 

> 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
> 추상화는 두 가지 단계로 이루어진다.
> * 첫 번째: 공통점을 취하는 **`일반화`**
> * 두 번째: 불필요한 세부사항을 제거하는 **`단순화`**

### ***추상화는 왜 필요할까?***
> 한 줄로 말하자면 단순하고 직관적이기 위해라고 표현할 수 있을 것이다.

### 개념과 인스턴스
> 개념: 공통점을 기반으로 객체들을 묶기 위한 그릇   
> 인스턴스: 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때 객체를 그 개념의 인스턴스라고 한다   
> 책에서는 "객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다." 라고
> 표현되어 있다.

### ***비유해서 표현해보지면***

`클래스를 구성하는 것이 개념, 해당 클래스의 객체를 생성하는 것이 인스턴스.` 
> 클래스란 어떤 사물 혹은 객체를 추상화하여 만들어 놓은 틀. 개념이다.   
> 인스턴스란 해당 개념을 적용할 수 있는 객체. 즉 해당 클래스로 만들어진 객체는 인스턴스이다.   


# 타입
> 타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는
> 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다.
> 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.


**하지만 타입은 컴퓨터 내부로 들어오는 순간 좀 더 기계적인 의미로 윤색된다고 한다.** 


그렇다면 ***`타입은 개념의 특수화`*** 라고 말할 수 있지 않을까 ? 


## 데이터 타입
> 컴퓨터가 어떤 작업을 수행하기 위해서는 필요한 데이터를 주기억장치(메모리)에 올려두어야 가능한데,    
> 이런 데이터들은 타입이 없는 무수히 많은 0과 1로 이루어진 비트열이다.


### 메모리에 저장된 '10010011'은 무엇을 의미할까? 
> 해당 값을 유추하긴 매우 힘들것이다. 왜냐하면 '10010011'이 숫자인지, 문자인지, 메모리의 주소 값인지 
> 우리는 모르기 때문이다.   
> 이러한 현상을 해결하기 위해 프로그래밍 언어에서 타입 시스템이 생겨난 것이다.   
> 즉, 컴퓨터 내부 영역에서의 타입이란 비트열을 구분할 수 있는 "개념"이다. 


### 데이터 타입에 관한 중요한 사실 2가지

> 첫째, 타입은 데이터가 어떻게 사용되느냐에 관한 것이다. 데이터를 더하거나 빼려면 숫자형 데이터 타입일 것이고, 데이터가 문자열형인 이유는 두 데이터를 연결해 새로운 문자열을 만들거나 문자열의 길이를 알 수 있기 때문이다.   
> 따라서 데이터가 어떤 타입에 속하는지를 결정하는 것은 데이터에 적용할 수 있는 `작업`이다.   
> 둘째, 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다.   
> 데이터 타입의 표현은 연산 작업을 수행하기에 가장 효과적인 형태가 선택되며, 개발자는 단지 데이터
> 타입에 적용할 수 있는 연산자만 알고있으면 된다.


***`데이터에 적용하는 작업을 "행동"으로 봐도 될까?`***
* 연산자를 통해 데이터의 상태를 변경시키기 때문에 "행동"이다.


### ***데이터 타입을 예를 들면***
> 정수를 저장하는 "short, long, int"    
> 실수를 저장하는 "float, double"   
> 문자를 저장하는 "char"   
> 문자열을 저장하는 "string" 등으로 데이터 타입을 구분하고 있다.



### **데이터 타입**은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다.
> * 메타데이터란, 데이터에 관한 구조화된 데이터로 다른 데이터를 설명해주는 데이터이다. 
> * 정보를 지적으로 통제하고 구조적으로 `접근`할 수 있도록 정보 유형을 정리한 2차적인 정보
> * 메타데이터의 또 다른 목적은 데이터를 빨리 찾기 위한 것으로 정보의 인덱스(index) 역할을 한다.

## ***`데이터에 대한 분류는 암시적으로 데이터에 대한 연산자를 결정한다`***


## 객체와 타입
> 실제로 객체지향 프로그램을 작성할 때 우리는 객체를 일종의 데이터처럼 사용한다.
> * 클래스 혹은 구조체의 경우에도 하나의 데이터 타입으로 사용한다.
> 따라서 객체를 타입에 따라 분류하고 해당 객체에 이름을 붙이는 것은 결국 새로운 데이터 타입을 선언하는 것과 같다.


### 데이터 타입에 관한 사실은 객체에도 동일하게 적용된다.
> 첫째, 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.   
> 어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.   
> 둘째, 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.   
> 객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다.


### 정리해보자면 
1. 객체의 타입을 결정하는 것은 객체의 행동뿐이다.
    * 데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 데이터를 외부로부터 숨겨야 한다는 사실이다.   
    이를 **`캡슐화`** 라고 부른다. 
    * 캡슐화는 객체를 행동에 따라 분류하기 위해 지켜야하는 기본 원칙인데 이를 위해서는 객체가 외부에 제공해야 하는 책임, 즉 행동을 먼저 결정하고 행동을 수행하는데 적합한 데이터를 나중에 결정한다.
    * 예를 들어, 사칙연산을 수행하는 객체를 만들기 위해서는 숫자형 데이터를 가지고 있어야 할 것이다.
2. 객체가 어떤 데이터를 보유하고 있는지는 타입을 결정하는데 아무런 영향을 미치지 않는다.
* 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다.   
-> 즉, 서로 다른 데이터이다.   
> 내부 데이터가 다르기 때문에 객체에서 받아들인 메세지를 처리하는 방식은 서로 다르다. 


### 같은 타입의 객체가 동일한 메세지를 다른 방식으로 처리하는 특성을 **`다형성`** 이라고 부른다.
> * 다형성의 예시로 "메소드 오버라이딩"이 있다.



## 타입의 계층
 앞서 타입은 개념과 동일하다고 했었다. 타입은 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념인데 여기에 **`일반화-특수화 관계`** 라는 것이 존재할 수 있다. 

### 트럼프와 트럼프 인간
> 이상한 나라의 앨리스 속에 등장하는 정원사, 병사, 신하, 왕자와 공주, 하객으로 참석한 왕과 왕비들, 하트 잭, 하트 왕과 하트 여왕을 주인공 앨리스는 "트럼프"라고 불렀다.   

### ***과연 앨리스가 트럼프라고 부르는 등장인물들은 정말 트럼프일까?***
> 트럼프 인간 타입의 정의를 "납작 엎드릴 수 있고 뒤집어질 수 있으며 몸이 종이처럼 좌우로 펄럭이는 존재"로 정의해보자. 일반적으로 트럼프 카드는 납작 엎드릴 수 있고 뒤집어질 수는 있지만 걸어다닐 수는 없다.   
> 트럼프 인간 타입의 객체는 트럼프 카드 객체의 모든 행동을 할 수 있을뿐만 아니라 추가적으로 걸어다니는 행동을 할 수 있다.


### 즉 앨리스가 "트럼프"라고 불렀던 등장인물들은 정확히 "트럼프"가 아닌 "트럼프 인간" 객체인 것이다.


### 일반화-특수화
> 다시 말해 트럼프 인간은 트럼프의 일종이지만 일반적인 트럼프 카드보다 좀 더 특화된 행동을 하는 객체이며, 이는 **`특수화`** 에 해당한다.    
> 모든 "트럼프 인간"은 "트럼프"이기 때문에 이 관점에서 "트럼프"는 "트럼프 인간"을 포괄하는 좀 더 일반적인 개념이다.   
> 트럼프 인간은 트럼프보다 좀 더 특화된 행동을 하는 특수한 개념이다.   
> 이 두 개념 사이의 관계를 ***`일반화-특수화`*** 관계라고 한다


* 트럼프와 트럼프 인간 모두 '납작 엎드릴 수 있고', '뒤집어질 수 있다'. 거기에 더해 트럼프 인간은 추가적인 행동을 더 할 수 있는데 바로 '걸을 때마다 몸이 종이처럼 좌우로 펄럭일 수 있다'는 것이다.
* 트럼프가 트럼프 인간의 일반화인 이유는 트럼프가 가진 모든 행동을 트럼프 인간이 `공통적`으로 수행할 수 있기 떄문이다.
* 트럼프 인간이 트럼프의 특수화인 이유는 트럼프가 가진 모든 행동을 할 수 있을 뿐만 아니라 자신에게만 특수화된 행동을 `추가적`으로 할 수 있기 때문이다.

> 데이터 타입 관점에서 바라보면 일반화-특수화 관계는 좀 더 일반적인 타입과 특수한 타입간의 관계이다.   
* 일반적인 타입을 **`슈퍼 타입`**   
* 특수한 타입을 **`서브 타입`** 이라고 한다.   

### ***어떤 타입을 다른 타입의 서브타입이라고 말할 수 있으려면 다른 타입을 대체할 수 있어야 한다*** [Liskov 1988]

* 트럼프 인간의 경우 납작 엎드리거나 뒤집어지기만 하는 경우에는 트럼프 카드를 대체하더라도 무방할 것이다.




# 정리
1. 일반화는 객체들의 공통점을 취하는 추상화이다.
    * **`타입은 추상화의 결과물`**
2. 일반화-특수화를 결정하는 것은 객체의 **`행동`** 이다.
3. 객체는 데이터를 행동만으로 결정하여 상태를 숨기는 **`캡슐화`** 와 같은 행동을 하는 같은 타입의 객체가 동일한 메세지를 수신하여 서로 다른 방식으로 메세지를 처리하는 **`다형성`** 을 포함한다.
4. 타입은 객체를 분류하기 위한 것이다. 
    * 타입 또한 상태의 동적인 변화를 단순화한 추상화이다.
5. 클래스는 타입을 구현하는 방법중 하나이다.







# 의문점


### 책의 일부분을 인용해보자면 
> 그렇다면 객체는 데이터인가? 그렇지 않다. 다시 한번 강조하지만 객체에서 중요한 것은 객체의 행동이다. 상태는
> 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념일 뿐이다. 객체를 창조할 때 가장
> 중요하게 고려해야 하는 것은 객체가 이웃하는 객체와 협력하기 위해 어떤 행동을 해야 할지를 결정하는 것이다.
> 즉, 객체가 협력을 위해 어떤 책임을 지녀야 하는지를 결정하는 것이 객체지향 설계의 핵심이다.


## ***`왜 객체는 데이터가 아닐까?`***
* ### 객체는 데이터 타입이지 데이터는 아니다.