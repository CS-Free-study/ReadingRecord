# 협력하는 객체들의 공동체

> *조영호, 『객체지향의 사실과 오해』, 위키북스(2015)* 인용 및 주석입니다.

> 책을 읽으면서 인상깊었던 부분에 대해 인용과 함께 설명을 덧붙여 보았습니다.

## 본문 발췌

소프트웨어 개발자의 역할은 단순히 소프트웨어 안으로 옮겨담는 것이 아니라 고객과 사용자를 만족할 수 있는 신세계를 창조하는 것이다. (p. 21)

> 현실 세계와 소프트웨어가 꼭 대응될 필요는 없습니다. 실재로부터 소프트웨어로의 대응은 그럭저럭 무난할 수 있으나 반대의 연결은 어려운 경우가 다수 존재합니다. 현실 세계에는 물리적 실체를 찾아볼 수 없고 소프트웨어 속에서 개념상으로만 존재하는 객체가 있을 수 있습니다. 예를 들어 `FileUploader`나 `Session`, `Context` 같은 것들이 있습니다. `Context`에 대응되는 현실 세계의 물체가 있을까요? 객체지향은 현실 세계를 모방하는 것이 목적이 아니기 때문에 이러한 대응의 부재는 자연스럽습니다.

> 개발자의 책임 범위는 모방이 아닌 재창조까지입니다. 현실 세계와 다른 소프트웨어 세계의 특성을 이해하고 그에 맞는 합리적 설계를 도출해내어 고객과 사용자를 만족시켜야 합니다. 전체는 부분의 합보다 큽니다. 개발자의 책임도 모든 객체의 책임의 합보다 큽니다.

객체지향 설계라는 예술은 적절한 객체에게 적절한 책임을 할당하는 것에서 시작된다. (p. 30)

> 객체지향의 주 개념은 크고 복잡한 일을 잘게 나누어 적당한 책임을 가진 객체들에게 나누어준 뒤 그들로 하여금 스스로의 역할을 수행하며 다른 객체와 협력하여 일을 마치도록 하는 것입니다. 이러한 관점에서 볼 때 책임의 부적절한 분배는 객체지향의 채택을 무의미하게 만들어 버립니다. 객체들은 하나의 책임만을 가져야 합니다(SRP).

외부의 도움을 무시한 채 모든 것을 스스로 처리하려고 하는 전지전능한 객체(god object)는 내부적인 복잡도에 의해 자멸하고 만다. (pp. 31 ~ 32)

> 안타깝게도, 오늘도 수많은 프로그램들이 걷고 있는 길입니다. 큰 객체 하나로 모든 것을 하려고 하면 객체지향의 이점을 전혀 누릴 수 없습니다.

객체는 다른 객체가 '무엇(what)'을 수행하는지는 알  수 있지만 '어떻게(how)' 수행하는지에 대해서는 알 수 없다. (p. 33)

> 객체는 목적을 이루기 위해 다른 객체에게 어떠한 기능의 수행을 요청할 수 있을 뿐, 그 기능을 수행하는 상세한 절차나 방법에 대해 이러쿵저러쿵 할 수 없습니다. 객체가 요청을 거절할 수도 있습니다. 친구끼리 돈을 빌리는 상황을 가정해보겠습니다. `돈 빌려줘`라는 요청을 할 수 있습니다. `돈 빌려줘`라는 요청에 대해 반응하는 방법은 스스로 정합니다. 요청을 받은 친구는 주머니에서 돈을 꺼내거나 ATM에서 현금을 인출하거나 계좌이체로 돈을 보내줄 수 있습니다. 당연히 요청을 거절할 수도 있지요. 객체는 이처럼 자율성을 가집니다. 반면 잘못 설계된 프로그램이라면 친구는 `돈 빌려줘`를 요청하는 대신 그 친구의 주머니를 털어 잔액을 확인한 다음 충분하면 그것을 가져갈 것이고, 부족하면 휴대폰을 빼앗아 은행 앱으로 송금을 할 것입니다. 이게 가능하려면 돈을 털어가는 녀석이 털리는 친구 주머니의 위치, 휴대전화의 비밀번호, 계좌 현황을 모두 알아야 하지요. 그래서 이런 식으로 짜다 보면 *전지전능한 객체*가 탄생합니다.

프로그래밍 언어는 프로그래머의 사고를 지배하지 않는다. 다만 어떤 언어가 다른 언어에 비해 특정한 사고를 좀 더 수월하게 표현할 뿐이다. (p. 36)

> C로도 객체지항 설계를 도입할 수 있습니다. Java보다 조금 불편할 뿐이지요.

훌륭한 객체지향 설계자가 되기 위해 거쳐야 할 첫 반째 도전은 코드를 담는 클래스의 관점에서 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환하는 것이다. (p. 38)

> 클래스는 객체지향 사고를 담아내는 그릇 중 하나일 뿐입니다. 다른 방법도 있습니다. 가장 먼저 떠오르는 것으로, 자바스크립트의 프로토타입 기반 객체 생성과 상속이 있네요.
